<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="fire-base.html">
<!--
`fire-query` is the generic firebase-data-query element as well 
- for pull-queries (get) , if  as 
- for push-queries (save)  
The actions are triggered by changes 
@element fire-query
@demo demo/cloud-query.html
-->

<dom-module id="fire-query">

  <template>

    <style>
      :host {
        display: block;
      }
    </style>
    
    <fire-base app="{{app}}" fb="{{fb}}" ></fire-base>

  </template>

  <script>

    Polymer({
      is: 'fire-query',

      properties: {
        /**
         * Key of requested firebase-app
         * @type {String}
        */
        app: {  
          type: String
        },
        /**
         * Firebase app
         * @type {Object}
         */
        fb: {
          type: Object
        },

        path:{
          type: String
        },

        // CTRL-param 
        lastpath:{
          type: String
        },

        // filter(order)Item
        item: {         
          type: String   
          // value: "_all_"  
        },
        
        // filterValue (of orderItem)
        itemvalue:{     
          type: String
          // value: "_all_"  
        },

        // operator(relating queryItem and queryValue)
        operator: {      
          type: String
        },

        data: {
          type: Object,
          notify: true
        },

        // Save one doc (keyvalue/keydata)
        keyvalue: {
          type: String
        },  

        keydata: {
          type: Object
        }, 
        
        // Save multiple docs to same parentPath
        updatedata: {
          type: Object
        },

        /**
         * ctrl decides mode of fbdb-update, see fbSet
         */
        updatectrl: true,  

        okflag: {
          value:  false,
          notify: true
        },  

        toast : {
          type: String,
          notify: true
        }
      },

      observers: [
        '_fbQuery(fb, path, item, itemvalue)',
        '_fbSet(fb, path, updatedata, updatectrl)'
      ],

      ready: function() { // console.log("firequery-ready");
      },

      logKeydata: function(v) {
        // console.log("log", v);
      },

      /**
       * Debounce shells
       *  
       */
      _fbQuery: function(fb, path, item, value) { 
        this.debounce('fbQuery', function () { // console.log("DebouncedStart fbQuery:", path, item, value);
          this.fbQuery(fb, path, item, value); 
        }, 100);
      },

      _fbSet: function(fb, parentPath, updateData, ctrl) { 
        this.debounce('fbSet', function () { // console.log("DebouncedStart fbQuery:", path, item, value);
          this.fbSet(fb, parentPath, updateData, ctrl); 
        }, 100);
      },

      /**
       * Query content from fb database
       * @param  {[type]} fb     [description]
       * @param  {[type]} path   [description]
       * @param  {[type]} item   [description]
       * @param  {[type]} value) {             console.log(path, item, value [description]
       * @return {[type]}        [description]
       */
      fbQuery: function(fb, path, item, value) {  console.log("fb:queryArguments:", path, item, value, typeof value); 

        var op   = this.operator, // optional operator 
            ops  = ["<", ">", "!"],
            self = this,
            count = this.count; 

        var queryMake = function (ref, value, count) {  
         
          if (typeof value == "string") { // Refine "ref" for wildcards and operators 

            var wildcard, numvalue,
                wildStarPos = value.indexOf("*"),
                wildHashPos = value.indexOf("#"); // 
           
            if (ops.indexOf(value.substring(0,1)) >= 0) {
              op    = value.substring(0,1);
              value = value.substring(1); 
            }   

            if (wildStarPos > 0) { 

              wildcard = value.substring(0, wildStarPos);   console.log("wildcardStar Query: ", "path="+path, "var="+ item, "wild=" + wildcard); 
              ref = ref.startAt(wildcard).endAt(wildcard+"\uf8ff");

            } else if (wildHashPos > 0) {
              var von = value.replace(/#/g, "0"),
                  bis = value.replace(/#/g, "9");

              wildcard = value.substring(0, wildHashPos);   console.log("wildcardHash Query: ", "path="+path, "var="+ item, "von="+von, "bis="+bis); 
              ref = ref.startAt(parseFloat(von)).endAt(parseFloat(bis));
            }    
         
          } 

          numvalue = parseFloat(value);  
       
          if (!isNaN(numvalue)) value = numvalue;

          if (!op) {             console.log("fb:strictValueQuery: ", "path="+path, "var="+ item, "val=" + value); 
            
              ref = ref.equalTo(value);
            // if (isNaN(numvalue)) ref = ref.equalTo(value);
            // else             ref = ref.equalTo(numvalue);

          } else if (op=="<") {  console.log("fb:rangeQuery < : ", "path="+path, "var="+ item, "val=" + value); 
             
              ref = ref.startAt(0).endAt(value);

          } else if (op==">") {  console.log("fb:rangeQuery > : ", "path="+path, "var="+ item, "val=" + value); 
             
              ref = ref.startAt(value);
          }   

          // OPTIONAL : return 'count' records(objects) only 
          if (count > 0) { 
            ref = ref.limitToFirst(count); console.log("query max. "+count+" documents only: ", ref);
          } // console.log("fbQuery prepared: ", ref);

          return ref;  
        };

        // 1.1 Query nodes at path (without item-query)    
        if (item == "_all_") {  console.log("fb:pathQuery: ", "path="+path);

          fb.database().ref(path).once('value').then(
            function(snapshot) {  console.log("fb:queryResult", snapshot.val());
              self.data = snapshot.val();
              // return snapshot.val();
            },
            function(error) {     console.log("fb:queryError", error);
              return; 
            })
        }
        // 1.2 wildcard-item-query : NOT (YET) AVAILABLE
        // if (item.indexOf("*") >= 0) {   console.log("check existence of multiple 'wildcarded' properties"); 


        // 2.1 BUILD the fbQuery 
        var queries = [];

        var ref = fb.database()
                    .ref(path)
                    .orderByChild(item);

        if (value == '_all_') {  console.log("fb:itemAllQuery: ", "path="+path, "var="+ item);

          ref = ref.startAt(0).endAt("z");       // query numeric + string values
          // ref = ref.startAt("A").endAt("z");  // all string values  
          // ref = ref.startAt("a").endAt("z");  // lowercase string values only  
          // ref = ref.startAt("A").endAt("Z");  // uppercase string values only  
          // OPTIONAL : return 'count' records(objects) only 

          if (count > 0) ref = ref.limitToFirst(count); 

          queries[0] = ref.once("value").then(function(snap){return snap.val();}) ; // queryMake(ref, value, count); 
        
        } else if (Array.isArray(value)) { console.log("fb:itemValueListQuery: ", "path="+path, "var="+ item, value);
          // query records for multiple values of a property
          var values = value;
          var refMake = function(val) {
            var q = queryMake(ref, val, count),
                q = q.once("value").then(function(snap) {
                  return snap.val();
                });
            return q;
          }
          
          queries = values.map(refMake);

        } else {  console.log("fb:itemValueQuery: ", "path="+path, "var="+ item, value);
      
          ref = queryMake(ref, value, count); 
          
          queries[0] = ref.once("value").then(function(snap){return snap.val();}) ; // queryMake(ref, value, count); 

        } // console.log("queries", queries);


        // 2.2 APPLY the fbQuery and return results 
        //     Does not work with "return" to a 'computed property'
        // console.log("ref to apply:", ref);     
        // ref.once('value')
        Promise.all(queries)
           .then(function(qdata) { // console.log("fb:queryResult, value(",self.item,", ",self.itemvalue,")=", qdata); // , merged);
              var alldata = {}; 
             
              // Use reduce-function
              // var mergedata = function(total, data) {
              //   Object.keys(data).forEach(function(k){ 
              //     total[k] = data[k];
              //   })
              // }
              // alldata = qdata.reduce(mergedata, {});
             
              // Simple approach
              qdata.forEach(function(data){
                if (data != null) {
                  Object.keys(data).forEach(function(k){
                    alldata[k] = data[k];
                  })
                }    
              });   // console.log("alldata", alldata);
             
              self.data = alldata;
              // return alldata; 
           })
           .catch( function (errorObject) { console.log("fb:queryFailed with " + errorObject.code);  
              // self.itemvalue = undefined;
              return;
           });
      },

      /**
       * Insert/replace a set of objects/documents into common parentPath
       * @param  {string} fb         [description]
       * @param  {string} parentPath [description]
       * @param  {object} updateData collection of path/document pairs 
       * @param  {any}    ctrl       controls type of save operation  
       * @return {Boolean}           successflag 
       */
      fbSet: function(fb, parentPath, updateData, ctrl) { console.log("fbSet STARTING", ctrl, typeof updateData);  
        // save the doc-reference to database
        if ((typeof updateData != "object") || (Object.keys(updateData).length==0)) { 
          console.log("Empty dataObject to submit into ", parentPath)
          return; 
        } console.log("fb:set childs in path="+parentPath, Object.keys(updateData).length, ctrl); // return; 

        // 2. update fb with updateData at parentPath 
        
        //    target-path-node must exist 
        //    to enable childs key-generator
        if (!fb.database().ref().child(parentPath)) { 
          fb.database().ref(parentPath).set([]);
        }  
        var that = this;

        //  2.1  replace complete node-content
        if (ctrl=="_parent_") {  

          fb.database().ref(parentPath)
             .set(updateData)
             .then(function(){  console.log("node-replace done!", updateData)
                that.okflag = true; 
             })
             .catch(function(){ console.log("err-node-replace"); 
                that.okflag = false; 
             }); 
          return;    
        }      

        // 2.2 update childNodes existing in parentPath 
        //   = map updateData into array of fb-setPromises

        var updateNodes = function(ref, updateData, replace) { 
          // Update ref-childnodes with nodedata
          var updateNode = function(k) {
            // if (!ref.child(k)) return Promise.resolve();
            // A. Replace  
            if (replace) return  ref.child(k).set(updateData[k]);

            // B. Update all items defined in updateData for node k
            var refchild = ref.child(k),
                nodeData = updateData[k];  

            var updateItem = function(item) {
              return refchild.child(item).set(nodeData[item]);
            }

            return Object.keys(nodeData).map(updateItem);  
          }; 

          return Object.keys(updateData).map(updateNode);
        };  

        var updateNodeItems  = function(ref, updateData, item) {
          // Update ONE item(property) of ref-childnodes 
          // if it is set in updateData 
          var updateItem = function(k) {
            if (updateData[k][item]) { 
              var refchild = ref.child(k); 
              // if (!refChild) return Promise.resolve(); 
              return refchild.child(item).set(updateData[k][item]);
            }
            return Promise.resolve(); // dummy promise 
          }; 

          return Object.keys(updateData).map(updateItem);  
        };

        var ref = fb.database().ref(parentPath);
        
        var allP=[];   

        Promise.resolve(updateData)
        .then(function(data){     // console.log("ctrl=", ctrl); 
          
          // Create an array of  
          if (ctrl == "_replace_") {             console.log("fb:Set Replace COMPLETE content of child-nodes by updateData");

            allP = updateNodes(ref, data, true);  

          } else if (ctrl == "_update_") {       console.log("fb:Set Update/append all properties of child-nodes passed in updateData"); 

            allP = updateNodes(ref, data);   

          } else if (typeof ctrl == "string") {  console.log("fb:Set Replace ONE property in all child-nodes"); 

            allP = updateNodeItems(ref, data, ctrl); // Object.keys(data).map(updateItem);  

          } else if (Array.isArray(ctrl)) {      console.log("fb:Set Replace MULTIPLE properties in child-nodes"); 

            ctrl.forEach(function(item){ 

              allP = allP.concat(updateNodeItems(ref, data, item));  

            })

          } else {                               console.log("fb:Set Replace all properties of child-nodes as defined in ??? "); 

            allP = updateNodes(ref, data);   

          } // console.log(allP.length + " Promises", allP );
        
          return Promise.all(allP);           // !!!
          //***********************
        })
        .then (function(values){
          console.log("fb:Set done for n=" + values.length + " nodes"); // , values)
          that.okflag   = true; 
          that.updatedata = undefined;
        })
        .catch(function() {
          console.log("err-childs-update");
          that.okflag   = false; 
          that.updatedata = undefined;
        }); 

      },

      /**
       * Remove docs from fb-database
       * @param  {[type]} fb         [description]
       * @param  {[type]} parentPath [description]
       * @param  {[type]} ctrl       [description]
       * @return {[type]}            [description]
       */
      // fbDelete: function(fb, parentPath, ctrl) {

      //   this.fbSet(fb, parentPath, ctrl); 

      // }  

    });
  </script>

</dom-module>