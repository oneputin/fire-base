<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="fire-base.html">
<!--
`fire-query` is the generic firebase-data-query element as well 
- for pull-queries (get) , if  as 
- for push-queries (save)  
The actions are triggered by changes 
@element fire-query
@demo demo/cloud-query.html
-->

<dom-module id="fire-query">

  <template>

    <style>
      :host {
        display: block;
      }
    </style>
    
    <fire-base app="{{app}}" fb="{{fb}}" ></fire-base>

  </template>

  <script>

    Polymer({
      is: 'fire-query',
      properties: {
        /**
         * Key of requested firebase-app
         * @type {String}
         */
        app: {  
          type: String
        },
        /**
         * Firebase app
         * @type {Object}
         */
        fb: {
          type: Object
        },

        path:{
          type: String
        },

        // CTRL-param 
        lastpath:{
          type: String
        },

        // query(order)Item
        item: {         
          type: String   
        },
        
        // queryValue (of orderItem)
        itemvalue:{     
          type: String,
          value: "_all_"  
        },

        // operator(relating queryItem and queryValue)
        operator: {      
          type: String
        },

        data: {
          type: Object,
          notify: true
        },

        // Save one doc (keyvalue/keydata)
        keyvalue: {
          type: String
        },  
        keydata: {
          type: Object
        }, 
        
        // Save multiple docs to same parentPath
        pathdata: {
          type: Object
        },

        toast : {
          type: String,
          notify: true
        }
      },

      observers: [
        'fbPathQuery(fb, path, item)',
        'fbItemQuery(fb, path, item, itemvalue)', 
        'fbKeySave(fb, path, keyvalue, keydata)',
        'fbPathSave(fb, path, pathdata)'
      ],

      ready: function() { // console.log("firequery-ready");
      },

      logKeydata: function(v) {
        // console.log("log", v);
      },

      /* */  
      fbPathQuery: function(fb, path, item) { 

        if (!item || (item == "_all_")) {  console.log("fbPathQuery, path=", path, item); 

          // var that = this; // ALTMODISCH (use bind() instead?)
          fb.database().ref(path).once('value').then(function(snapshot) { 
            console.log("snapped pathmode", snapshot.val());
            this.data = snapshot.val();
          }.bind(this))
        }
      },

      /* */
      fbItemQuery: function(fb, path, item, value) {  

        if (!item || (item == "_all_")) return;  

        var op  = this.operator, // optional operator 
            ops = ["<", ">", "!"];

        var ref = fb.database()
                    .ref(path);

        if (item.indexOf("*") >= 0) { // console.log("check existence of multiple "wildcarded" properties"); 



        } else if (value && (value != '_all_') ) {

          ref = ref.orderByChild(item);
          
          var wildcardpos = value.indexOf("*"); // 
         
          if (ops.indexOf(value.substring(0,1)) >= 0) {
            op    = value.substring(0,1);
            value = value.substring(1); 
          }   

          if (wildcardpos > 0) { 

            var wildcard = value.substring(0, wildcardpos);   console.log("wildcardQuery: ", "path="+path, "var="+ item, "wild=" + wildcard); 

            ref = ref.startAt(wildcard).endAt(wildcard+"\uf8ff");

          } else {

            var vnum = parseFloat(value);  
            if (!isNaN(vnum)) value = vnum;
            
            if (!op) {            console.log("strictValueQuery: ", "path="+path, "var="+ item, "val=" + value); 
                ref = ref.equalTo(value);
              // if (isNaN(vnum)) ref = ref.equalTo(value);
              // else             ref = ref.equalTo(vnum);
            } else if (op=="<") {  console.log("rangeQuery < : ", "path="+path, "var="+ item, "val=" + value); 
                ref = ref.startAt(0).endAt(value);
            } else if (op==">") {  console.log("rangeQuery > : ", "path="+path, "var="+ item, "val=" + value); 
                ref = ref.startAt(value);
            }   

          } // console.log("fbItemQuery prepared: ", ref); 

        } else { // DEFAULT QUERY if no specific value queried 

            ref = ref.orderByChild(item);
            ref = ref.startAt(0).endAt("z");    // numeric + string values
            // ref = ref.startAt("A").endAt("z");     // all string values  
            // ref = ref.startAt("a").endAt("z");  // lowercase string values only  
            // ref = ref.startAt("A").endAt("Z");  // uppercase string values only  
        }

        // OPTIONAL : return 'count' records(objects) only 
        var count = this.count; 
        if (count > 0) { 
          ref = ref.limitToFirst(count); console.log("query max. "+count+" documents only: ", ref);
        } 

        var that = this; // ALTMODISCH (use bind() instead?)

        // APPLY the query 
        ref.once('value')
           .then(function(snapshot) {  // console.log("snapshot-value", snapshot.val());
              that.data = snapshot.val();
           })
           .catch( function (errorObject) {
              console.log("FBserver: The read failed with " + errorObject.code);  
           });
      },

      /* */ 
      fbKeySave: function(fb, parentPath, keyValue, keyData) { 

        // save the doc-reference to database
        if ((typeof keyData == Object) && !Object.keys(keyData).length) { 
          console.log("Empty dataObject to submit into ", parentPath, keyValue)
          return; 
        } // console.log("triggered to save at FB:", parentPath, keyValue, keyData);
        // return; 
        // debugger; 

        // 1. 
        if (!fb.database().ref().child(parentPath)) { // target-path-node must exist to enable key-generator
          fb.database().ref(parentPath).set([]);
        }  

        // 2. Get unique key for the dataObject at the target path ??? 
        if (!keyValue) keyValue = fb.database().ref().child(parentPath).push().key;   // console.log("keyDataSubmit", keyValue, keyData); // return;

        var targetPath = parentPath+'/'+keyValue;

        //  3. Store&check the dataObject
        //  3.1 STORE
        fb.database().ref(targetPath).set(keyData);  console.log("saved at:", targetPath);
        
        //  3.2 CHECK-Option
        if (1) {
          var log;
          fb.database().ref(targetPath)
                       .once('value')
                       .then(function(snapshot) { 
                          log = snapshot.val().log;  console.log("data were saved in: "+targetPath, ", log: "+log); // , snapshot.val());
                          this.lastpath = targetPath; 
                        }.bind(this));
        }

        // 4. RESET  to avoid save when only one of the pair is altered !!
        
        this.keyvalue = undefined; 
        this.keydata  = undefined; 
      },  


      fbSave : function(key, data) { // create a promise to save a data(doc) at key 
        // Return a new promise.
        return new Promise(function(resolve, reject) {
          // Do the usual XHR stuff
          var req = new XMLHttpRequest();
          req.open('GET', url);

          req.onload = function() {
            // This is called even on 404 etc
            // so check the status
            if (req.status == 200) {
              // Resolve the promise with the response text
              resolve(req.response);
            }
            else {
              // Otherwise reject with the status text
              // which will hopefully be a meaningful error
              reject(Error(req.statusText));
            }
          };

          // Handle network errors
          req.onerror = function() {
            reject(Error("Network Error"));
          };

          // Make the request
          req.send();
        });
      },

      /* use a promiseChain to */ 
      fbPathSave: function(fb, parentPath, pathData) {
        // save the doc-reference to database
        if ((typeof pathData == Object) && !Object.keys(pathData).length) { 
          console.log("Empty dataObject to submit into ", parentPath)
          return; 
        } console.log("triggered to save at FB:", parentPath, pathData);
        return; 
        // debugger; 

        // 1. 
        if (!fb.database().ref().child(parentPath)) { // target-path-node must exist to enable key-generator
          fb.database().ref(parentPath).set([]);
        }  

        // 2. 
        // getpathData(pathData).then(function(result){
        //   return Promise.all(result.keys.map(function (data) { 
        //     return fbSave(key, data);
        // }))
        // .then(function(allSaved) {
        //   return xxx;
        // })  
        // .catch(console.log("error-catch"))


        this.pathdata = undefined;
      }  

    });
  </script>

</dom-module>